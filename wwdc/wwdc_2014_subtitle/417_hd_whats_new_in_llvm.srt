

1
00:00:12.356 --> 00:00:13.336 A:middle
&gt;&gt; Good morning!

2
00:00:13.616 --> 00:00:13.796 A:middle
Welcome!

3
00:00:14.516 --> 00:00:17.136 A:middle
[ Applause ]

4
00:00:17.636 --> 00:00:20.886 A:middle
Glad to see a number of folks
out now, bright and early,

5
00:00:20.886 --> 00:00:23.906 A:middle
to talk about all the
heart-pounding excitement

6
00:00:23.906 --> 00:00:25.276 A:middle
in the world of compilers.

7
00:00:26.026 --> 00:00:31.396 A:middle
And I'm Jim Grosbach, and I'm
really happy to be here today

8
00:00:31.396 --> 00:00:35.746 A:middle
to share with you all of the
new things that we have in LLVM.

9
00:00:37.106 --> 00:00:42.226 A:middle
When we normally talk about LLVM
and what first comes to mind

10
00:00:42.226 --> 00:00:46.296 A:middle
when we think about it is the
Apple LLVM Compiler itself.

11
00:00:46.646 --> 00:00:51.146 A:middle
This is what we all use to
build our apps and that's

12
00:00:51.146 --> 00:00:53.276 A:middle
where we really first
encounter LLVM,

13
00:00:53.966 --> 00:00:57.136 A:middle
but it's much more than that.

14
00:00:57.886 --> 00:01:03.266 A:middle
LLVM is used in a wide
variety of products and tools

15
00:01:03.766 --> 00:01:09.436 A:middle
that we all use every day, both
as developers and as end users.

16
00:01:10.866 --> 00:01:16.326 A:middle
Over the years LLVM has grown to
be a really key technology here

17
00:01:16.326 --> 00:01:19.566 A:middle
at Apple for building
tools, for performance,

18
00:01:20.146 --> 00:01:25.996 A:middle
and for modernization, and that
has been no exception this year

19
00:01:26.496 --> 00:01:28.276 A:middle
as we have moved swiftly along

20
00:01:29.226 --> 00:01:32.106 A:middle
with a wide variety
of new improvements.

21
00:01:33.666 --> 00:01:38.806 A:middle
To start with, back in September
we introduced the Apple A7

22
00:01:38.806 --> 00:01:43.086 A:middle
processor which has been
just absolutely magnificent

23
00:01:43.206 --> 00:01:44.516 A:middle
in what it's allowed us to do,

24
00:01:44.826 --> 00:01:47.366 A:middle
bringing truly desktop-class
performance

25
00:01:48.076 --> 00:01:53.166 A:middle
to your mobile devices and
LLVM plays a key role in this.

26
00:01:54.226 --> 00:01:59.546 A:middle
And now we're encouraging more
of you to use this technology

27
00:01:59.546 --> 00:02:03.396 A:middle
in your apps, so
building for 64-bit

28
00:02:03.676 --> 00:02:05.546 A:middle
in iOS is now the default.

29
00:02:05.626 --> 00:02:09.515 A:middle
As of Xcode 5.1 carrying
on into Xcode 6,

30
00:02:10.235 --> 00:02:11.546 A:middle
when you rebuild your app,

31
00:02:12.486 --> 00:02:14.146 A:middle
if you're using standard
architectures,

32
00:02:14.616 --> 00:02:16.676 A:middle
ARM64 will be included.

33
00:02:17.406 --> 00:02:19.926 A:middle
This does not impact
your deployment story.

34
00:02:19.926 --> 00:02:23.466 A:middle
You can continue to
deploy back to iOS 4.3.

35
00:02:23.466 --> 00:02:26.786 A:middle
We still build for
arm V7 for 32 bit.

36
00:02:27.626 --> 00:02:30.546 A:middle
All of the development work
flows that you're familiar

37
00:02:30.546 --> 00:02:34.346 A:middle
with for the simulator,
the debugger, profiling,

38
00:02:34.916 --> 00:02:38.066 A:middle
all of these things continue
to work transparently,

39
00:02:38.526 --> 00:02:41.636 A:middle
just as you're familiar with
in a 64-bit environment.

40
00:02:42.506 --> 00:02:44.926 A:middle
Now, one thing to be aware of is

41
00:02:44.926 --> 00:02:49.166 A:middle
that because ARM64 is an
entirely new architecture,

42
00:02:49.856 --> 00:02:52.786 A:middle
your entire application
must be built 64 bit,

43
00:02:53.256 --> 00:02:54.826 A:middle
not just a few libraries here,

44
00:02:54.826 --> 00:02:57.526 A:middle
or a few files there,
but the whole app.

45
00:02:57.746 --> 00:03:00.586 A:middle
So, if you're relying
on third-party libraries

46
00:03:01.286 --> 00:03:05.416 A:middle
and those libraries have
not yet adopted 64 bit,

47
00:03:06.036 --> 00:03:10.506 A:middle
please work with your vendors
and encourage them to update

48
00:03:10.746 --> 00:03:12.796 A:middle
and support 64 bit development

49
00:03:13.146 --> 00:03:16.276 A:middle
so that your app
can then migrate

50
00:03:16.276 --> 00:03:18.116 A:middle
as well and get the benefits.

51
00:03:18.666 --> 00:03:22.526 A:middle
Now, during migration there
are a few things that we'd

52
00:03:22.526 --> 00:03:26.426 A:middle
like to bring to your
attention that might come up,

53
00:03:26.426 --> 00:03:29.586 A:middle
a few advancements we've
made, and a few things

54
00:03:29.586 --> 00:03:31.676 A:middle
that we've tightened
up in the specification

55
00:03:31.806 --> 00:03:35.406 A:middle
and what the possible
impact of that tier app is.

56
00:03:35.956 --> 00:03:42.556 A:middle
To start with, in 64-bit iOS all
functions must have a prototype.

57
00:03:43.096 --> 00:03:47.116 A:middle
This has been good style
since time immemorial

58
00:03:47.596 --> 00:03:51.496 A:middle
and it's been required
for C++ since the start.

59
00:03:51.886 --> 00:03:55.156 A:middle
It's been highly suggested in C,

60
00:03:55.276 --> 00:03:58.636 A:middle
for any modern version not
using a prototype is deprecated

61
00:03:59.306 --> 00:04:01.976 A:middle
and has been for a
very long time now.

62
00:04:03.206 --> 00:04:06.546 A:middle
So, we've taken advantage
of this in ARM64

63
00:04:06.986 --> 00:04:10.156 A:middle
to generate more efficient
calling convention code,

64
00:04:10.396 --> 00:04:12.866 A:middle
in particular for variatic
functions like printf,

65
00:04:12.866 --> 00:04:14.866 A:middle
that the number of arguments

66
00:04:15.166 --> 00:04:17.476 A:middle
to the function varies
by call site.

67
00:04:18.995 --> 00:04:21.805 A:middle
So, when you have older
code that you're using

68
00:04:21.805 --> 00:04:23.356 A:middle
that may not use prototypes,

69
00:04:24.176 --> 00:04:27.496 A:middle
what is normally a warning has
now been promoted to an error,

70
00:04:27.496 --> 00:04:31.646 A:middle
so the compiler will highlight
to you in your code exactly

71
00:04:31.736 --> 00:04:35.766 A:middle
where this is happening so
that you know which prototypes

72
00:04:35.766 --> 00:04:38.156 A:middle
to go add to your
header files to move on.

73
00:04:39.796 --> 00:04:42.786 A:middle
One place that this
does sometimes come

74
00:04:42.786 --> 00:04:46.556 A:middle
up in a little bit more
of a subtle way is when C

75
00:04:46.556 --> 00:04:50.116 A:middle
and Objective-C interworking
code with direct indications

76
00:04:50.116 --> 00:04:51.816 A:middle
of Objective-C message send.

77
00:04:52.466 --> 00:04:54.946 A:middle
To help find this, we
have a new Xcode setting

78
00:04:55.536 --> 00:04:58.896 A:middle
to enable strict checking
of objc underscore msgSend.

79
00:05:00.366 --> 00:05:01.706 A:middle
This is a recommended setting

80
00:05:02.796 --> 00:05:05.236 A:middle
and when you first
upgrade your project

81
00:05:05.236 --> 00:05:07.396 A:middle
to [inaudible] code
6 we'll encourage you

82
00:05:07.506 --> 00:05:08.546 A:middle
to adopt this setting.

83
00:05:08.546 --> 00:05:12.926 A:middle
And what's tricky is
that every indication

84
00:05:12.926 --> 00:05:15.816 A:middle
of objc underscore
msgSend effectively has a

85
00:05:15.816 --> 00:05:16.636 A:middle
different type.

86
00:05:17.466 --> 00:05:22.196 A:middle
It has the type of what the
final receiving method is going

87
00:05:22.196 --> 00:05:22.646 A:middle
to be.

88
00:05:23.696 --> 00:05:26.566 A:middle
For example here,
a trivial piece

89
00:05:26.566 --> 00:05:29.906 A:middle
of code that's invoking
method foo,

90
00:05:31.046 --> 00:05:36.446 A:middle
with strict checking enabled,
the compiler will now tell us

91
00:05:36.576 --> 00:05:40.236 A:middle
that we need to tell it
what the final type is.

92
00:05:41.136 --> 00:05:42.466 A:middle
This is straightforward to do.

93
00:05:42.466 --> 00:05:44.956 A:middle
It's a little bit verbose,
but very straightforward.

94
00:05:44.956 --> 00:05:47.736 A:middle
We simply add the type of
the final receiving method.

95
00:05:48.146 --> 00:05:49.406 A:middle
Done it here with a typedef.

96
00:05:49.446 --> 00:05:52.856 A:middle
This could be done with a direct
type test on all on one line,

97
00:05:52.856 --> 00:05:54.866 A:middle
if you prefer, just to make sure

98
00:05:54.866 --> 00:05:57.646 A:middle
that the compiler knows what
the final receiving type

99
00:05:57.646 --> 00:06:01.046 A:middle
of the method is so that it
can generate the right code

100
00:06:01.296 --> 00:06:02.926 A:middle
to get the final result correct.

101
00:06:05.016 --> 00:06:08.296 A:middle
Another place that we've
tightened things up

102
00:06:08.296 --> 00:06:09.916 A:middle
and taken advantage
of our new ABI

103
00:06:09.916 --> 00:06:13.856 A:middle
and ARM64 is the
Objective-C Boolean type.

104
00:06:14.276 --> 00:06:17.776 A:middle
If any of you were at <i>Stump
the Experts </i>last night,

105
00:06:17.776 --> 00:06:19.916 A:middle
this topic actually
came up as a question.

106
00:06:20.396 --> 00:06:23.306 A:middle
It was rather amusing like,
"I have a slide on that!

107
00:06:23.456 --> 00:06:25.116 A:middle
That'll be great!"

108
00:06:25.116 --> 00:06:27.596 A:middle
So, BOOL is basically
now a BOOL type.

109
00:06:28.716 --> 00:06:31.666 A:middle
Previously, it's been
a signed character.

110
00:06:32.156 --> 00:06:36.726 A:middle
And, sometimes our code -- our
code as well, not just in yours,

111
00:06:37.326 --> 00:06:39.756 A:middle
would put values
into the Boolean type

112
00:06:39.786 --> 00:06:41.876 A:middle
that weren't strictly Boolean.

113
00:06:42.946 --> 00:06:46.606 A:middle
Now, the compiler is going to
be taking advantage of this type

114
00:06:46.606 --> 00:06:48.796 A:middle
or definition, so
what can happen is

115
00:06:48.796 --> 00:06:52.346 A:middle
that if your code does that,
the results between 32-bit iOS

116
00:06:52.696 --> 00:06:55.106 A:middle
and 64-bit iOS may differ.

117
00:06:56.046 --> 00:06:59.066 A:middle
So, if you start seeing some
odd behaviors with Booleans,

118
00:06:59.366 --> 00:07:03.326 A:middle
this is something
to look out for.

119
00:07:04.946 --> 00:07:06.296 A:middle
We also have pointers.

120
00:07:07.516 --> 00:07:10.196 A:middle
As we're now 64-bit
architecture, this is kind

121
00:07:10.196 --> 00:07:12.666 A:middle
of the core of what this
is all about, that pointers

122
00:07:12.666 --> 00:07:14.266 A:middle
and longs are now 64 bits.

123
00:07:15.226 --> 00:07:19.146 A:middle
So, old code would
often do horrible things

124
00:07:19.146 --> 00:07:21.916 A:middle
like casting integers to
pointers, and back-and-forth.

125
00:07:22.866 --> 00:07:25.286 A:middle
And hopefully, we don't write
code that does that anymore,

126
00:07:25.286 --> 00:07:28.026 A:middle
but we all have this legacy
code that we have to live with,

127
00:07:29.076 --> 00:07:32.176 A:middle
and now this can bite
us if we're not careful.

128
00:07:32.486 --> 00:07:34.736 A:middle
This is very similar
to what we've all dealt

129
00:07:34.736 --> 00:07:38.876 A:middle
with on the 32-bit to
64-bit Intel transition,

130
00:07:38.876 --> 00:07:39.816 A:middle
if we went through that.

131
00:07:40.616 --> 00:07:41.496 A:middle
That's still a problem;

132
00:07:41.496 --> 00:07:43.826 A:middle
we haven't magically just
solved that in the compiler.

133
00:07:44.886 --> 00:07:48.946 A:middle
So for example here, we're
casting an integer which came

134
00:07:48.946 --> 00:07:50.106 A:middle
from a pointer somewhere else.

135
00:07:50.106 --> 00:07:51.816 A:middle
We're casting that to a void.

136
00:07:51.816 --> 00:07:55.186 A:middle
But now the compiler
can help a little bit.

137
00:07:55.186 --> 00:08:00.196 A:middle
It can at least inform us
that the problem is coming up

138
00:08:00.196 --> 00:08:03.636 A:middle
and tell us that, "Oh, we have a
problem here that we need to go

139
00:08:03.636 --> 00:08:04.606 A:middle
and look at and make sure

140
00:08:04.606 --> 00:08:06.796 A:middle
that this is really
what's happening."

141
00:08:07.596 --> 00:08:09.176 A:middle
Now, if we ignore this warning,

142
00:08:09.796 --> 00:08:12.656 A:middle
the runtime in the
kernel is going

143
00:08:12.656 --> 00:08:15.036 A:middle
to be a little bit more
forceful about this.

144
00:08:15.606 --> 00:08:19.116 A:middle
If we dereference that pointer
we're going to get a hard fault

145
00:08:19.916 --> 00:08:22.936 A:middle
because the page zero is
mapped to always give a fault

146
00:08:22.936 --> 00:08:26.236 A:middle
so if we miss any of these
through other warnings,

147
00:08:26.806 --> 00:08:27.916 A:middle
we'll still get an error.

148
00:08:28.406 --> 00:08:29.696 A:middle
Paying attention
to the compiler,

149
00:08:29.696 --> 00:08:32.106 A:middle
it's going to be a lot
friendlier because it'll be nice

150
00:08:32.106 --> 00:08:34.515 A:middle
and friendly and tell you the
line number and the source file

151
00:08:34.576 --> 00:08:35.496 A:middle
for where the problem is.

152
00:08:35.716 --> 00:08:37.756 A:middle
The kernel's just going to
tell you you did something bad.

153
00:08:39.246 --> 00:08:43.666 A:middle
To address this we use
the C language typedefs

154
00:08:44.456 --> 00:08:46.776 A:middle
that are 64 and 32-bit cleaned.

155
00:08:46.776 --> 00:08:49.596 A:middle
We say we want a signed
integer, an unsigned integer,

156
00:08:49.816 --> 00:08:53.086 A:middle
that is an appropriate type
for saving a pointer value

157
00:08:53.386 --> 00:08:55.306 A:middle
or for indexing into an array

158
00:08:55.746 --> 00:08:58.466 A:middle
for comparing the differences
between two pointers.

159
00:08:59.446 --> 00:09:02.026 A:middle
For example, if we would
modify our previous code

160
00:09:02.026 --> 00:09:05.566 A:middle
to simply use the intptr type,
which when we're compiling

161
00:09:05.566 --> 00:09:08.726 A:middle
for 32-bit iOS, will we
get 32-bit signed integer,

162
00:09:09.126 --> 00:09:13.726 A:middle
and for 64-bit iOS will be
a 64-bit signed integer.

163
00:09:14.456 --> 00:09:18.686 A:middle
Slightly more subtly, this can
come up in structure layouts.

164
00:09:19.496 --> 00:09:23.266 A:middle
When we use a long or pointer
these now grow, which change

165
00:09:23.636 --> 00:09:26.236 A:middle
but the size and
sometimes the alignment,

166
00:09:26.236 --> 00:09:28.836 A:middle
the offsets of other
fields in our structures.

167
00:09:29.486 --> 00:09:30.576 A:middle
And, we have to be careful

168
00:09:30.576 --> 00:09:32.646 A:middle
that this is done in
a way that's safe.

169
00:09:33.876 --> 00:09:36.586 A:middle
Now, most of time this is
going to work transparently,

170
00:09:36.586 --> 00:09:38.856 A:middle
because these structures
are used entirely

171
00:09:38.856 --> 00:09:40.236 A:middle
within our application

172
00:09:40.236 --> 00:09:42.926 A:middle
and everything gets the new
definition and works fine.

173
00:09:44.146 --> 00:09:46.806 A:middle
But, if we're doing something
like a representation

174
00:09:46.806 --> 00:09:50.556 A:middle
of an on-disk file format
communicating across a network

175
00:09:50.556 --> 00:09:54.436 A:middle
to another process that is going
to rely on the exact layout

176
00:09:54.436 --> 00:09:58.056 A:middle
of a structure, that
can go badly.

177
00:09:58.056 --> 00:10:01.086 A:middle
So again, on any of those
data structures we want

178
00:10:01.086 --> 00:10:07.496 A:middle
to use the C fixed type,
fixed size types to make sure

179
00:10:07.496 --> 00:10:09.316 A:middle
that we get what we want,
whether we're building

180
00:10:09.316 --> 00:10:12.876 A:middle
for 64-bit iOS or
for 32-bit iOS.

181
00:10:14.756 --> 00:10:18.166 A:middle
So in summary, building
for 64-bit iOS is easy,

182
00:10:18.636 --> 00:10:23.596 A:middle
it's a default, and the
compiler will help find

183
00:10:23.596 --> 00:10:25.136 A:middle
and resolve any issues.

184
00:10:26.116 --> 00:10:29.736 A:middle
But, this isn't the only
thing that we've been up to.

185
00:10:29.816 --> 00:10:33.056 A:middle
We've also been making
advances in Objective-C

186
00:10:34.086 --> 00:10:36.596 A:middle
and the compiler
can help here, too.

187
00:10:37.996 --> 00:10:39.906 A:middle
The language has
continued to move forward.

188
00:10:40.386 --> 00:10:43.166 A:middle
Some of this really helps with
the interoperability with SWF

189
00:10:43.286 --> 00:10:46.006 A:middle
as well, as you may be
seeing in that talk.

190
00:10:46.006 --> 00:10:47.656 A:middle
I highly encourage
you to check it out.

191
00:10:47.656 --> 00:10:50.116 A:middle
It's happening at the same time
as this one, so go and look

192
00:10:50.116 --> 00:10:53.516 A:middle
on the video when that
comes on the WWDC app.

193
00:10:53.566 --> 00:10:59.776 A:middle
And, whenever we write new
code, we've been using all

194
00:10:59.776 --> 00:11:02.046 A:middle
of these advancements
in the language

195
00:11:02.626 --> 00:11:05.436 A:middle
to get the modern best
practices, more expressive code,

196
00:11:05.436 --> 00:11:10.386 A:middle
but then we have all of this
older legacy code that we'd

197
00:11:10.386 --> 00:11:12.776 A:middle
like to adopt all of these
features in, as well.

198
00:11:13.026 --> 00:11:15.436 A:middle
But, that's a lot of
code to go read through

199
00:11:15.436 --> 00:11:19.216 A:middle
and manually find all of these
things, so we have a tool

200
00:11:19.216 --> 00:11:22.196 A:middle
that will help us
identify the opportunities

201
00:11:22.746 --> 00:11:24.686 A:middle
where we can use
these new features.

202
00:11:24.926 --> 00:11:28.496 A:middle
And, I think the best
way to talk about that is

203
00:11:28.496 --> 00:11:32.066 A:middle
to show you with the demo.

204
00:11:32.686 --> 00:11:37.576 A:middle
Now, rather than use some
contrived example code here,

205
00:11:37.576 --> 00:11:39.376 A:middle
I thought we'd maybe
look at something

206
00:11:39.376 --> 00:11:40.966 A:middle
that we all are familiar with,

207
00:11:40.966 --> 00:11:44.326 A:middle
at least as users,
and our WWDC app.

208
00:11:45.236 --> 00:11:47.246 A:middle
That code has been
with us for a while.

209
00:11:47.246 --> 00:11:48.696 A:middle
We update it every year.

210
00:11:49.126 --> 00:11:53.326 A:middle
And, with the modernizer we
wanted to use that to look at it

211
00:11:53.326 --> 00:11:55.986 A:middle
and find out if there
are perhaps some places

212
00:11:55.986 --> 00:11:58.486 A:middle
in the codebase that we
missed for opportunities

213
00:11:59.496 --> 00:12:01.516 A:middle
to use new Objective-C features.

214
00:12:02.396 --> 00:12:04.786 A:middle
So, let's look and
see what a few

215
00:12:04.786 --> 00:12:06.396 A:middle
of those things that
we found are.

216
00:12:06.876 --> 00:12:11.246 A:middle
If we go under Edit to refactor,
we can convert our project

217
00:12:11.356 --> 00:12:13.246 A:middle
to modern Objective-C syntax.

218
00:12:14.136 --> 00:12:16.796 A:middle
We get a dialog box telling
us what we've just selected,

219
00:12:16.896 --> 00:12:18.676 A:middle
so make sure that we've
got the right thing.

220
00:12:20.476 --> 00:12:21.486 A:middle
We can select whether --

221
00:12:21.566 --> 00:12:23.886 A:middle
which targets in our
project to modernize.

222
00:12:23.886 --> 00:12:26.876 A:middle
In this case, we're looking
at the WWDC app, itself.

223
00:12:27.476 --> 00:12:32.406 A:middle
In the previous versions of
Xcode the modernizer would go

224
00:12:32.466 --> 00:12:33.716 A:middle
through and just look

225
00:12:33.806 --> 00:12:36.246 A:middle
for Objective-C literals
and subscripting.

226
00:12:36.246 --> 00:12:38.596 A:middle
But now, we have more options.

227
00:12:39.606 --> 00:12:42.476 A:middle
Now personally, I prefer not
to do all of these at once.

228
00:12:42.476 --> 00:12:45.566 A:middle
That tends to be a little too
much to swap back-and-forth,

229
00:12:45.596 --> 00:12:48.156 A:middle
so I tend to want to
select a few things.

230
00:12:48.446 --> 00:12:51.616 A:middle
I'm going to look for
instance type here

231
00:12:51.616 --> 00:12:53.866 A:middle
that we can get our
initialization methods more

232
00:12:53.866 --> 00:12:54.616 A:middle
strongly typed.

233
00:12:54.616 --> 00:12:58.596 A:middle
I'm going to try and find if we
missed any read/write properties

234
00:12:58.596 --> 00:13:01.726 A:middle
where we convert explicit
getter/setter methods.

235
00:13:02.316 --> 00:13:05.116 A:middle
And, we're going to
look to use NS ENUM

236
00:13:05.496 --> 00:13:08.766 A:middle
for our enumeration values
so the compiler can cooperate

237
00:13:08.766 --> 00:13:11.156 A:middle
with the runtime to
give better results.

238
00:13:12.246 --> 00:13:16.736 A:middle
Click Next, and the compiler
will run over our code

239
00:13:16.986 --> 00:13:20.216 A:middle
and it turns out we do, indeed,
have a few more suggestions

240
00:13:20.216 --> 00:13:21.506 A:middle
for what we can look at.

241
00:13:22.176 --> 00:13:25.016 A:middle
Now, do keep in mind that
these are just suggestions,

242
00:13:25.866 --> 00:13:27.406 A:middle
that we need to go
through and look

243
00:13:27.406 --> 00:13:30.656 A:middle
at the side-by-side diff here,
where we have the new code

244
00:13:30.656 --> 00:13:35.026 A:middle
on the left, the old code on the
right, and we look through here.

245
00:13:35.026 --> 00:13:36.226 A:middle
This looks fine.

246
00:13:36.926 --> 00:13:38.196 A:middle
Everything looks good here.

247
00:13:38.196 --> 00:13:39.556 A:middle
We're converting to ENUMS.

248
00:13:40.066 --> 00:13:42.096 A:middle
Let's look at our next one.

249
00:13:42.936 --> 00:13:46.036 A:middle
This looks a little
bit different,

250
00:13:46.036 --> 00:13:50.686 A:middle
because we still have this NS
integer over here that looks

251
00:13:50.686 --> 00:13:52.196 A:middle
like it'd be straightforward
to clean up,

252
00:13:52.196 --> 00:13:54.116 A:middle
but I'd rather come
back to this later.

253
00:13:54.116 --> 00:13:55.076 A:middle
I just want to deal
with the things

254
00:13:55.076 --> 00:13:56.756 A:middle
that we can do automatically
right now.

255
00:13:57.416 --> 00:14:00.546 A:middle
So, I tell the modernizer
to discard that change.

256
00:14:00.996 --> 00:14:03.396 A:middle
It wants to make sure
that I'm doing that.

257
00:14:03.396 --> 00:14:04.966 A:middle
Yes, I am absolutely sure.

258
00:14:04.966 --> 00:14:07.396 A:middle
I can do the same here.

259
00:14:08.876 --> 00:14:11.646 A:middle
We could also tell it to ignore
all of the changes in this file

260
00:14:11.646 --> 00:14:12.846 A:middle
with this Check button here.

261
00:14:13.406 --> 00:14:16.366 A:middle
And now, it's also found a place

262
00:14:17.026 --> 00:14:18.396 A:middle
where we can use
an instance type.

263
00:14:18.696 --> 00:14:23.296 A:middle
And, that all looks good
so we tell it to save.

264
00:14:24.236 --> 00:14:26.086 A:middle
And, Xcode will now
tell us that, "Oh!

265
00:14:26.086 --> 00:14:29.926 A:middle
We can update our project as
well, and take snapshots."

266
00:14:30.376 --> 00:14:31.416 A:middle
That sounds great.

267
00:14:31.416 --> 00:14:33.216 A:middle
Let's let it do that
because backups are good.

268
00:14:33.216 --> 00:14:36.476 A:middle
And now, our project is
saved, it's been rebuilt,

269
00:14:37.286 --> 00:14:42.416 A:middle
and the Objective-C modernizer
works to update our code

270
00:14:42.416 --> 00:14:45.026 A:middle
and help us find places
where we can take advantage

271
00:14:45.326 --> 00:14:46.216 A:middle
of new features.

272
00:14:46.846 --> 00:14:51.046 A:middle
But, this isn't the only
place that we've made advances

273
00:14:51.616 --> 00:14:55.086 A:middle
for Objective-C and
for interoperability.

274
00:14:55.136 --> 00:14:58.886 A:middle
And, to tell you more about that
I'd like to invite my friend

275
00:14:58.886 --> 00:15:00.036 A:middle
and coworker, Bob Wilson.

276
00:15:00.246 --> 00:15:01.066 A:middle
Thank you, Bob.

277
00:15:02.516 --> 00:15:07.576 A:middle
[ Applause ]

278
00:15:08.076 --> 00:15:08.516 A:middle
&gt;&gt; Thank you, Jim.

279
00:15:10.186 --> 00:15:12.006 A:middle
So, modules are another way

280
00:15:12.096 --> 00:15:14.476 A:middle
that LLVM can help
modernize your code.

281
00:15:14.726 --> 00:15:18.066 A:middle
We introduced modules just last
year, but in cases you missed

282
00:15:18.066 --> 00:15:19.786 A:middle
that let's start
with some background.

283
00:15:22.056 --> 00:15:24.896 A:middle
So, before modules we
had precompiled headers,

284
00:15:25.136 --> 00:15:28.556 A:middle
which are often an effective
way to speed up the compilation

285
00:15:28.556 --> 00:15:31.286 A:middle
of your code, but they
do have some limitations.

286
00:15:32.196 --> 00:15:35.606 A:middle
You can only have one
precompiled header at a time,

287
00:15:36.516 --> 00:15:39.536 A:middle
and more importantly,
the whole approach

288
00:15:39.536 --> 00:15:43.156 A:middle
of using a textual inclusion
of a header file as a way

289
00:15:43.156 --> 00:15:45.846 A:middle
of importing a framework
is just fragile.

290
00:15:46.916 --> 00:15:48.396 A:middle
We have a deal with the issue

291
00:15:48.396 --> 00:15:51.266 A:middle
where a header file gets
included more than once

292
00:15:51.266 --> 00:15:52.406 A:middle
in a single compilation.

293
00:15:53.606 --> 00:15:55.986 A:middle
We have also a problem
of headers being fragile.

294
00:15:56.526 --> 00:15:59.346 A:middle
And, what I mean by
that is that the meaning

295
00:15:59.346 --> 00:16:01.956 A:middle
of the header can change
depending on the environment

296
00:16:02.236 --> 00:16:05.246 A:middle
where it's imported, and let me
show you that with an example.

297
00:16:06.706 --> 00:16:09.936 A:middle
So here, I've defined a macro
count to the value of 100,

298
00:16:10.266 --> 00:16:12.266 A:middle
and then I import the
foundation framework.

299
00:16:13.256 --> 00:16:17.056 A:middle
Now, inside the foundation
header there's an include

300
00:16:17.096 --> 00:16:18.586 A:middle
for the NSArray definition.

301
00:16:19.346 --> 00:16:21.786 A:middle
An NSArray has an
ivar, the count.

302
00:16:22.726 --> 00:16:26.896 A:middle
So, the macro of count gets
substituted as literal text

303
00:16:27.356 --> 00:16:30.296 A:middle
in that place and we end up
with completely broken code

304
00:16:30.296 --> 00:16:32.936 A:middle
where instead of the ivar
name, we have a value of 100.

305
00:16:33.856 --> 00:16:35.876 A:middle
This is what I mean by
headers being fragile.

306
00:16:37.296 --> 00:16:40.696 A:middle
Modules solve this problem
by replacing the model

307
00:16:40.696 --> 00:16:43.996 A:middle
of textual inclusion
with a semantic import.

308
00:16:44.326 --> 00:16:48.426 A:middle
And, there's a lot more detail
about modules in the Advances

309
00:16:48.426 --> 00:16:50.956 A:middle
in Objective-C presentation
from last year's WWDC

310
00:16:50.956 --> 00:16:52.556 A:middle
and I encourage you to watch

311
00:16:52.556 --> 00:16:54.146 A:middle
that if you're not
familiar with modules.

312
00:16:55.816 --> 00:16:58.466 A:middle
Until now, modules have
only been available

313
00:16:58.516 --> 00:16:59.776 A:middle
for the system frameworks.

314
00:17:00.486 --> 00:17:04.286 A:middle
The new in Xcode 6, you
can now define modules

315
00:17:04.476 --> 00:17:07.906 A:middle
for your own frameworks as
well for C and Objective-C.

316
00:17:09.156 --> 00:17:11.866 A:middle
Besides fixing the
problems we just looked at,

317
00:17:11.986 --> 00:17:13.356 A:middle
this also gives you a way

318
00:17:13.356 --> 00:17:16.886 A:middle
of importing your own
framework into your SWF code.

319
00:17:17.586 --> 00:17:19.286 A:middle
And as Jim mentioned,
there's another session

320
00:17:19.286 --> 00:17:22.336 A:middle
on integrating SWF with
Objective-C that I encourage you

321
00:17:22.336 --> 00:17:24.425 A:middle
to watch the video to
learn more about that.

322
00:17:25.675 --> 00:17:27.556 A:middle
So if you want to do this, how?

323
00:17:28.806 --> 00:17:29.986 A:middle
It's really very easy.

324
00:17:30.946 --> 00:17:32.926 A:middle
For most frameworks
it's possible

325
00:17:32.926 --> 00:17:35.656 A:middle
to define a single
umbrella header

326
00:17:35.916 --> 00:17:38.126 A:middle
that imports all of
the framework API.

327
00:17:38.606 --> 00:17:40.866 A:middle
And, this is what we
recommend that you do

328
00:17:41.276 --> 00:17:43.976 A:middle
as it is the easiest
way to adopt a module.

329
00:17:45.046 --> 00:17:48.046 A:middle
Once you've done that, simply
go to the Xcode BUILD settings

330
00:17:48.256 --> 00:17:52.756 A:middle
for your framework and in the
packaging section set Defines

331
00:17:52.756 --> 00:17:55.616 A:middle
Module to Yes, and that's it.

332
00:17:55.616 --> 00:17:57.176 A:middle
It really is very easy.

333
00:17:57.796 --> 00:17:59.896 A:middle
Now, if you have a more
complicated framework

334
00:18:00.116 --> 00:18:03.516 A:middle
where that single umbrella
header is not sufficient,

335
00:18:03.516 --> 00:18:05.146 A:middle
you can use a custom module map.

336
00:18:05.946 --> 00:18:08.236 A:middle
And, there's more
information to describe how

337
00:18:08.236 --> 00:18:09.846 A:middle
that works on the LLVM website.

338
00:18:12.036 --> 00:18:14.506 A:middle
After you've created a
module you'll want to use it.

339
00:18:15.396 --> 00:18:16.036 A:middle
How do you do that?

340
00:18:17.226 --> 00:18:21.516 A:middle
There's an @import keyword
followed by the module name

341
00:18:21.856 --> 00:18:24.076 A:middle
that tells the compiler, "I
want to import this module."

342
00:18:24.726 --> 00:18:27.636 A:middle
If you haven't had a
chance to update your code

343
00:18:27.636 --> 00:18:28.716 A:middle
and you're still --

344
00:18:28.716 --> 00:18:31.726 A:middle
have a #import to include
the umbrella header,

345
00:18:31.726 --> 00:18:33.986 A:middle
the compiler's smart
enough to know

346
00:18:34.206 --> 00:18:37.416 A:middle
that this is now a modular
framework and it will go ahead

347
00:18:37.416 --> 00:18:40.426 A:middle
and treat that as an implicit
modular import anyway.

348
00:18:41.966 --> 00:18:45.516 A:middle
So just as a guideline though,
we do recommend you use @import

349
00:18:46.396 --> 00:18:49.536 A:middle
when you're importing your
framework into a separate target

350
00:18:49.536 --> 00:18:53.036 A:middle
within your project just because
it makes it clear in the source

351
00:18:53.116 --> 00:18:56.326 A:middle
that you really intend for
this to be a modular import.

352
00:18:57.646 --> 00:19:00.466 A:middle
One exception to that is
within the implementation

353
00:19:00.466 --> 00:19:01.776 A:middle
of your framework, itself.

354
00:19:02.476 --> 00:19:05.746 A:middle
It doesn't make any sense to
import a framework into itself

355
00:19:05.746 --> 00:19:09.006 A:middle
and so, in that case, you
really need to use #import

356
00:19:09.006 --> 00:19:11.096 A:middle
to textually include
the framework headers,

357
00:19:11.276 --> 00:19:13.286 A:middle
just within the implementation
of the framework.

358
00:19:14.846 --> 00:19:17.616 A:middle
And, besides those guidelines,
we have a few other rules

359
00:19:17.616 --> 00:19:19.876 A:middle
about modules that you
should be aware of.

360
00:19:20.286 --> 00:19:23.916 A:middle
First, don't expose
any non-modular headers

361
00:19:23.916 --> 00:19:24.966 A:middle
in your framework API.

362
00:19:26.186 --> 00:19:28.786 A:middle
It's fine to import
another module, like Cocoa,

363
00:19:29.296 --> 00:19:32.266 A:middle
but if I have an import of
something like Postgres.h,

364
00:19:32.266 --> 00:19:34.226 A:middle
which presumably
is not a module,

365
00:19:34.986 --> 00:19:37.156 A:middle
you can put that down
inside the implementation

366
00:19:37.156 --> 00:19:40.366 A:middle
of your framework, but
don't expose it in the API.

367
00:19:42.596 --> 00:19:46.436 A:middle
One other issue is that
modules can change the semantics

368
00:19:46.526 --> 00:19:47.146 A:middle
of your code.

369
00:19:47.636 --> 00:19:50.386 A:middle
We saw earlier the
problem of a fragile header

370
00:19:50.496 --> 00:19:53.676 A:middle
where a macro definition
inadvertently broke the code.

371
00:19:54.206 --> 00:19:56.256 A:middle
Sometimes you might want
to do this on purpose,

372
00:19:56.286 --> 00:19:59.236 A:middle
and I'm showing here an example
where I've defined a macro,

373
00:19:59.336 --> 00:20:03.226 A:middle
DEBUG, as a flag to enable
additional debugging APIs

374
00:20:03.896 --> 00:20:04.726 A:middle
in my framework.

375
00:20:06.386 --> 00:20:08.806 A:middle
By switching that
framework to be a module,

376
00:20:08.806 --> 00:20:10.846 A:middle
the DEBUG macro defined

377
00:20:10.846 --> 00:20:13.066 A:middle
in my source code no
longer has any effect,

378
00:20:13.196 --> 00:20:14.426 A:middle
which is not what I wanted.

379
00:20:15.296 --> 00:20:17.726 A:middle
Now, that limitation
only applies to macros

380
00:20:17.726 --> 00:20:19.716 A:middle
that are defined
in the source code.

381
00:20:19.966 --> 00:20:22.066 A:middle
So, if you really want to
do something like this,

382
00:20:22.546 --> 00:20:26.146 A:middle
one alternative is to define
the macro on the command line

383
00:20:26.276 --> 00:20:27.726 A:middle
or in the Xcode build settings.

384
00:20:30.086 --> 00:20:31.716 A:middle
So, that is user-defined
modules.

385
00:20:31.906 --> 00:20:33.466 A:middle
It's really pretty
straightforward

386
00:20:33.466 --> 00:20:36.096 A:middle
in the common case, and it
gives you fast compilation,

387
00:20:36.436 --> 00:20:40.076 A:middle
clear semantics, and a way of
interoperating with SWF code.

388
00:20:42.396 --> 00:20:44.826 A:middle
So far, we've been
talking a lot about ways

389
00:20:44.826 --> 00:20:47.016 A:middle
that LLVM helps you
modernize your code

390
00:20:47.016 --> 00:20:52.106 A:middle
and adopt modern Objective-C
modules, but let's turn now

391
00:20:52.106 --> 00:20:53.346 A:middle
and look at performance,

392
00:20:53.446 --> 00:20:55.566 A:middle
which is the other theme
of this presentation.

393
00:20:56.846 --> 00:21:02.766 A:middle
Profile Guided Optimization, or
PGO, is a new feature in Xcode 6

394
00:21:03.316 --> 00:21:04.606 A:middle
and it gives you a way

395
00:21:04.606 --> 00:21:07.206 A:middle
of getting even more
performance out of your code.

396
00:21:08.436 --> 00:21:11.836 A:middle
Let me give you an overall
high-level understanding

397
00:21:11.836 --> 00:21:13.396 A:middle
of what this is about.

398
00:21:14.506 --> 00:21:17.426 A:middle
One of the inherent
challenges for the compiler is

399
00:21:17.426 --> 00:21:19.656 A:middle
that it has no way of
knowing what the input

400
00:21:19.656 --> 00:21:20.946 A:middle
to your program is going to be.

401
00:21:21.356 --> 00:21:24.006 A:middle
The only input to the
compiler is your source code.

402
00:21:25.176 --> 00:21:27.106 A:middle
So, the compiler has to assume

403
00:21:27.366 --> 00:21:29.346 A:middle
that all inputs are
equally likely.

404
00:21:30.506 --> 00:21:32.096 A:middle
There are some cases
where it can guess

405
00:21:32.536 --> 00:21:35.116 A:middle
that certain code paths will
be more common than others.

406
00:21:35.856 --> 00:21:39.346 A:middle
For example, it can assume that
going through a loop is going

407
00:21:39.346 --> 00:21:41.516 A:middle
to happen more often than
code outside of that loop.

408
00:21:42.246 --> 00:21:44.246 A:middle
But, those are just guesses
and there are a lot of things

409
00:21:44.246 --> 00:21:45.496 A:middle
that it simply can't know.

410
00:21:47.286 --> 00:21:50.616 A:middle
If we provide a profile
as an additional input

411
00:21:50.616 --> 00:21:55.486 A:middle
to the compiler it can now try
to optimize for the common case

412
00:21:55.816 --> 00:21:58.736 A:middle
and do a better job
of optimization.

413
00:21:59.216 --> 00:22:01.036 A:middle
And, what I mean
by a profile, here,

414
00:22:01.226 --> 00:22:03.876 A:middle
is simply a count how
many times each statement

415
00:22:03.876 --> 00:22:08.366 A:middle
in your app executes in a
typical run of your app.

416
00:22:09.086 --> 00:22:12.086 A:middle
You may be wondering, "How do
I get a profile like that?"

417
00:22:12.466 --> 00:22:14.166 A:middle
Again, we could use
the compiler here

418
00:22:14.826 --> 00:22:17.616 A:middle
to generate a special
instrumented app

419
00:22:17.676 --> 00:22:19.316 A:middle
that as it runs is going

420
00:22:19.316 --> 00:22:22.276 A:middle
to count how many times each
statement will executes.

421
00:22:22.606 --> 00:22:24.146 A:middle
And then, when your app finishes

422
00:22:24.146 --> 00:22:26.676 A:middle
with this special instrumented
version, it will write

423
00:22:26.676 --> 00:22:29.706 A:middle
out that profile which
we can then use for PGO.

424
00:22:31.896 --> 00:22:34.936 A:middle
So, how does the compiler
use that profile information?

425
00:22:35.736 --> 00:22:37.106 A:middle
There are an awful lot of ways.

426
00:22:37.236 --> 00:22:39.636 A:middle
So many optimizations
can benefit from this,

427
00:22:40.326 --> 00:22:41.916 A:middle
but I'm highlighting
just three here

428
00:22:41.916 --> 00:22:43.316 A:middle
that are particularly valuable.

429
00:22:43.946 --> 00:22:45.046 A:middle
One is to the inliner.

430
00:22:46.066 --> 00:22:48.166 A:middle
If we know that a
function is really hot,

431
00:22:48.166 --> 00:22:50.706 A:middle
and by that I mean it's
run a lot, over and over.

432
00:22:51.256 --> 00:22:54.936 A:middle
The inliner can be much more
aggressive about inlining that.

433
00:22:55.226 --> 00:22:57.016 A:middle
When we're generating
the code we can try

434
00:22:57.016 --> 00:22:59.696 A:middle
to layout the common
paths through your code

435
00:23:00.126 --> 00:23:02.246 A:middle
so that they're contiguous,
which makes it easy

436
00:23:02.246 --> 00:23:04.156 A:middle
for the processor
to run them fast.

437
00:23:04.986 --> 00:23:08.006 A:middle
And the register allocator
can also try to keep values

438
00:23:08.066 --> 00:23:12.466 A:middle
in registers throughout
those most common paths.

439
00:23:12.766 --> 00:23:14.006 A:middle
Let's look at an example just

440
00:23:14.006 --> 00:23:16.306 A:middle
to give you a better
understanding of this.

441
00:23:16.836 --> 00:23:20.286 A:middle
This is some C++ code that's
going to iterate over a set

442
00:23:20.286 --> 00:23:22.306 A:middle
of colored objects and
for each one it's going

443
00:23:22.306 --> 00:23:24.146 A:middle
to update the position
of the object.

444
00:23:24.596 --> 00:23:27.646 A:middle
So, at the top I've got
a loop over the objects,

445
00:23:28.206 --> 00:23:29.016 A:middle
and for each one I'm going

446
00:23:29.016 --> 00:23:30.956 A:middle
to call my Update
Position function.

447
00:23:32.066 --> 00:23:33.906 A:middle
And, Update Position is
going to look and see

448
00:23:34.166 --> 00:23:38.206 A:middle
if the object is red it moves in
a very simple horizontal line,

449
00:23:38.206 --> 00:23:39.456 A:middle
so the code is really simple.

450
00:23:40.146 --> 00:23:42.266 A:middle
But, if the object
is blue, let's assume

451
00:23:42.516 --> 00:23:44.696 A:middle
that the movement is
much more complicated,

452
00:23:44.696 --> 00:23:46.796 A:middle
I've got a very large
block of code here.

453
00:23:48.126 --> 00:23:51.416 A:middle
Now, the compiler has no way
of knowing whether red objects

454
00:23:51.416 --> 00:23:53.216 A:middle
or blue objects are more likely,

455
00:23:53.256 --> 00:23:56.196 A:middle
so it just assumes they're
both equally likely.

456
00:23:56.196 --> 00:23:59.856 A:middle
But, with PGO I might
be able to know

457
00:23:59.856 --> 00:24:02.796 A:middle
that red objects
are far more common.

458
00:24:03.326 --> 00:24:05.906 A:middle
And so, I'm highlighting
in red here the hot code,

459
00:24:06.346 --> 00:24:09.116 A:middle
which is the code to iterate
over the set of objects and then

460
00:24:09.116 --> 00:24:10.546 A:middle
to handle the red objects.

461
00:24:11.536 --> 00:24:14.986 A:middle
I'm going to color-code
the cold code in blue,

462
00:24:15.016 --> 00:24:16.736 A:middle
which is blue objects
which are rare

463
00:24:16.736 --> 00:24:18.346 A:middle
for some reason in
this application.

464
00:24:19.216 --> 00:24:22.056 A:middle
And then, let's look at how the
compiler would handle this code.

465
00:24:24.016 --> 00:24:27.786 A:middle
Here's kind of the default code
layout that matches, roughly,

466
00:24:27.786 --> 00:24:29.286 A:middle
the original source order.

467
00:24:29.606 --> 00:24:31.416 A:middle
We've got the hot loop outside,

468
00:24:31.416 --> 00:24:34.346 A:middle
and then the Update
Position function down below,

469
00:24:34.556 --> 00:24:37.536 A:middle
with a little bit
of hot code in it.

470
00:24:38.486 --> 00:24:41.606 A:middle
Inlining is one of the most
important optimizations

471
00:24:42.346 --> 00:24:45.826 A:middle
and we'd really like to inline
that Update Position function.

472
00:24:46.226 --> 00:24:48.686 A:middle
But, the compiler
can't inline everything

473
00:24:49.266 --> 00:24:52.586 A:middle
or the code would bloat beyond a
point where it would be useful.

474
00:24:53.796 --> 00:24:57.006 A:middle
But in this case, the Update
Position function is big

475
00:24:57.046 --> 00:24:59.916 A:middle
because of all that cold code
for handling the blue objects

476
00:25:00.876 --> 00:25:02.646 A:middle
and so it wouldn't
normally be inlined.

477
00:25:02.956 --> 00:25:05.866 A:middle
But, because PGO tells us
there's some really hot code

478
00:25:05.866 --> 00:25:09.896 A:middle
here, the inliner can be much
more aggressive about that

479
00:25:09.896 --> 00:25:11.216 A:middle
in this particular case.

480
00:25:11.936 --> 00:25:16.046 A:middle
So, we take the loop iterating
over the objects and split

481
00:25:16.046 --> 00:25:20.546 A:middle
that in half and move the Update
Position code right inline.

482
00:25:21.416 --> 00:25:22.706 A:middle
So, this is much better now.

483
00:25:22.706 --> 00:25:25.406 A:middle
We've got a lot of the
hot code right together,

484
00:25:25.406 --> 00:25:29.966 A:middle
but we've still got a big chunk
of this code for blue objects,

485
00:25:29.966 --> 00:25:31.816 A:middle
the cold code, right in
the middle of our loop.

486
00:25:32.696 --> 00:25:36.596 A:middle
And, PGO can help this, as well,
by changing the code layout.

487
00:25:36.926 --> 00:25:40.456 A:middle
It knows that that code is cold
and can move it down below,

488
00:25:40.456 --> 00:25:43.436 A:middle
out of the way, and we end
up with a nice tight loop

489
00:25:43.746 --> 00:25:45.016 A:middle
that can run really fast.

490
00:25:45.536 --> 00:25:48.906 A:middle
And, it also typically
enables other optimizations

491
00:25:48.906 --> 00:25:49.906 A:middle
on that hot code.

492
00:25:51.146 --> 00:25:53.416 A:middle
So obviously, this is
a simplified example,

493
00:25:53.416 --> 00:25:56.216 A:middle
but hopefully gives you a
feel of the power of PGO

494
00:25:56.216 --> 00:25:58.486 A:middle
and just how much it
can help the optimizer.

495
00:26:00.056 --> 00:26:01.606 A:middle
So, you may want to use it.

496
00:26:02.406 --> 00:26:03.496 A:middle
When does it make sense?

497
00:26:04.406 --> 00:26:07.746 A:middle
The compiler does a really
good job optimizing by default.

498
00:26:08.916 --> 00:26:11.636 A:middle
With PGO, if you do just
a little bit of extra work

499
00:26:11.856 --> 00:26:15.146 A:middle
to gather the profile
you can do even better.

500
00:26:15.826 --> 00:26:17.666 A:middle
So obviously, if you're happy

501
00:26:17.666 --> 00:26:19.616 A:middle
with the performance
you're already getting,

502
00:26:20.126 --> 00:26:21.806 A:middle
you're probably not
motivated to do that --

503
00:26:22.036 --> 00:26:23.506 A:middle
even that little
bit of extra work.

504
00:26:23.936 --> 00:26:25.966 A:middle
But, if you need
more performance,

505
00:26:26.486 --> 00:26:28.486 A:middle
by all means, give it a try.

506
00:26:29.136 --> 00:26:31.066 A:middle
And, let me show
you some examples

507
00:26:31.066 --> 00:26:32.436 A:middle
of just how much it can help.

508
00:26:33.676 --> 00:26:36.886 A:middle
This is a graph showing
the speedup.

509
00:26:36.886 --> 00:26:38.876 A:middle
Compare it with PGO
compared to a case

510
00:26:38.876 --> 00:26:40.636 A:middle
of just a normal optimize build.

511
00:26:41.446 --> 00:26:44.206 A:middle
And, I'm looking at four
different applications here;

512
00:26:44.206 --> 00:26:47.516 A:middle
the Apple LLVM compiler
itself, applying PGO

513
00:26:47.606 --> 00:26:50.766 A:middle
to the compiler itself,
the SQLite database,

514
00:26:51.246 --> 00:26:53.596 A:middle
the PERL interpreter, and
gzip file compression.

515
00:26:54.676 --> 00:26:56.736 A:middle
And, PGO gives us
speedups ranging

516
00:26:56.736 --> 00:26:59.456 A:middle
from about 4% all
the way up to 18%.

517
00:27:00.786 --> 00:27:02.806 A:middle
So, not all apps will
benefit this much.

518
00:27:03.026 --> 00:27:04.646 A:middle
It really varies,
depending on the app,

519
00:27:05.116 --> 00:27:07.426 A:middle
but clearly there's a
lot of potential here.

520
00:27:09.676 --> 00:27:12.606 A:middle
So, if you want to try it,
how do you go about that?

521
00:27:13.166 --> 00:27:15.016 A:middle
PGO is really easy to use.

522
00:27:15.616 --> 00:27:17.476 A:middle
The first step is to
collect a profile.

523
00:27:17.476 --> 00:27:20.186 A:middle
I'm going to come back and talk
about that in just a minute.

524
00:27:21.286 --> 00:27:24.146 A:middle
Once you've done that, simply
go in the Xcode Build settings

525
00:27:24.146 --> 00:27:27.676 A:middle
for your project and find
the Use Optimization Profile

526
00:27:27.676 --> 00:27:30.096 A:middle
setting, and set it
to Yes, typically just

527
00:27:30.096 --> 00:27:31.446 A:middle
for the release configuration.

528
00:27:32.216 --> 00:27:32.886 A:middle
And that's it!

529
00:27:32.886 --> 00:27:34.576 A:middle
You've enabled PGO.

530
00:27:35.696 --> 00:27:36.576 A:middle
Once you've done that,

531
00:27:36.576 --> 00:27:39.326 A:middle
as you continue developing
your app you may change it

532
00:27:39.326 --> 00:27:41.176 A:middle
as you fix bugs, you
add new features,

533
00:27:41.876 --> 00:27:44.336 A:middle
the code becomes
gradually out of sync

534
00:27:44.336 --> 00:27:46.136 A:middle
with the profile you've
collected earlier.

535
00:27:47.096 --> 00:27:50.996 A:middle
And, when that happens, the
compiler will simply fail to use

536
00:27:50.996 --> 00:27:52.486 A:middle
that profile information.

537
00:27:52.486 --> 00:27:53.636 A:middle
It won't break anything,

538
00:27:53.636 --> 00:27:56.666 A:middle
you just gradually lose
the optimization benefit.

539
00:27:56.666 --> 00:27:58.986 A:middle
And when that happens, it
will give you a warning.

540
00:27:59.966 --> 00:28:01.636 A:middle
So, if you see warnings
like this,

541
00:28:01.636 --> 00:28:04.866 A:middle
saying that your profile may
be out of date, as you see more

542
00:28:04.866 --> 00:28:06.866 A:middle
and more of them, it's a good
indication to you that's time

543
00:28:06.866 --> 00:28:09.376 A:middle
to go back and update
your profile.

544
00:28:10.726 --> 00:28:13.876 A:middle
So, let's turn now and look at,
how do you generate the profile?

545
00:28:15.166 --> 00:28:19.406 A:middle
Xcode 6 has a new command,
Generate Optimization Profile.

546
00:28:20.096 --> 00:28:21.176 A:middle
When you run this command,

547
00:28:21.376 --> 00:28:24.316 A:middle
Xcode will build the special
instrumented version of your app

548
00:28:24.316 --> 00:28:27.096 A:middle
and then run it, and
you can then interact

549
00:28:27.096 --> 00:28:29.506 A:middle
with the running app to
generate the profile.

550
00:28:29.506 --> 00:28:31.616 A:middle
When it finishes running, it
will write out the profile

551
00:28:31.616 --> 00:28:32.956 A:middle
and add it to your project.

552
00:28:34.316 --> 00:28:37.156 A:middle
As you're running your app,
keep in mind it's important

553
00:28:37.156 --> 00:28:40.056 A:middle
to exercise all of the
code that's important

554
00:28:40.056 --> 00:28:41.076 A:middle
for your performance.

555
00:28:41.626 --> 00:28:43.906 A:middle
If I have a game with
three different levels

556
00:28:44.416 --> 00:28:47.966 A:middle
and I only play the first level
of my game, the compiler's going

557
00:28:47.966 --> 00:28:49.856 A:middle
to assume that that's the
only thing that really matters

558
00:28:49.856 --> 00:28:52.096 A:middle
and not work as hard
on the other levels.

559
00:28:54.356 --> 00:28:57.166 A:middle
Now, you may be wondering, "If
I've written a really hard game,

560
00:28:57.936 --> 00:29:00.746 A:middle
it may take a while to play
the whole thing to completion."

561
00:29:01.396 --> 00:29:03.476 A:middle
That could be a problem, right?

562
00:29:03.546 --> 00:29:05.966 A:middle
So, Xcode has another option,

563
00:29:07.116 --> 00:29:10.076 A:middle
which is to use your
performance tests as inputs

564
00:29:10.076 --> 00:29:11.286 A:middle
to drive the profiling.

565
00:29:12.496 --> 00:29:15.296 A:middle
Performance tests are a
new feature in Xcode 6.

566
00:29:15.796 --> 00:29:17.246 A:middle
If you'd like to
learn more about them,

567
00:29:17.376 --> 00:29:19.096 A:middle
there's a session right
here tomorrow morning

568
00:29:19.096 --> 00:29:20.756 A:middle
on testing in Xcode 6.

569
00:29:21.586 --> 00:29:25.436 A:middle
And, if you care about
performance you want to set

570
00:29:25.436 --> 00:29:28.406 A:middle
up these performance tests
anyway, to catch regressions

571
00:29:28.406 --> 00:29:30.406 A:middle
in your code, just to keep
track of how you're doing.

572
00:29:31.296 --> 00:29:34.276 A:middle
And once you've gone to
that trouble to set them up,

573
00:29:34.776 --> 00:29:36.906 A:middle
in most cases they're
pretty good inputs

574
00:29:36.906 --> 00:29:38.176 A:middle
for driving this profile.

575
00:29:40.106 --> 00:29:42.396 A:middle
Again though, keep in
mind it's important

576
00:29:42.596 --> 00:29:45.116 A:middle
that your tests cover
the code in a way

577
00:29:45.116 --> 00:29:47.566 A:middle
that reflects the
typical usage of your app.

578
00:29:47.946 --> 00:29:51.066 A:middle
Going back to my three-level
game, if I write lots of tests

579
00:29:51.066 --> 00:29:53.356 A:middle
for the first level and
only a few for the second

580
00:29:53.356 --> 00:29:56.006 A:middle
and third level, again,
the compiler's going to end

581
00:29:56.006 --> 00:29:59.216 A:middle
up optimizing more heavily
for that first level.

582
00:30:00.656 --> 00:30:03.416 A:middle
Another benefit of using tests
is it gives you a great way

583
00:30:03.746 --> 00:30:06.306 A:middle
of evaluating, how
much does PGO help me?

584
00:30:06.306 --> 00:30:07.726 A:middle
You can just run your tests.

585
00:30:08.086 --> 00:30:10.286 A:middle
Now, let me show you
that with a demo now.

586
00:30:12.376 --> 00:30:14.556 A:middle
So, with the release
of the SWF language,

587
00:30:15.286 --> 00:30:18.026 A:middle
we thought it would be
fun to make a demo app

588
00:30:18.026 --> 00:30:19.016 A:middle
that would celebrate that.

589
00:30:19.986 --> 00:30:21.566 A:middle
And so, rather than
the SWF language,

590
00:30:21.566 --> 00:30:25.056 A:middle
we thought of the SWF birds
and we made an application

591
00:30:25.196 --> 00:30:28.326 A:middle
that uses the Boids
Artificial Life Simulation

592
00:30:29.326 --> 00:30:30.816 A:middle
to simulate a flock of SWFs.

593
00:30:33.146 --> 00:30:35.206 A:middle
And, I can create a
whole bunch of them here

594
00:30:35.206 --> 00:30:36.436 A:middle
and let them fly around.

595
00:30:36.516 --> 00:30:40.686 A:middle
And, the way this Boids
application works is

596
00:30:40.686 --> 00:30:44.986 A:middle
that each bird, or Boid,
compares its position to all

597
00:30:44.986 --> 00:30:48.346 A:middle
of the other ones on the screen
and it calculates the distance

598
00:30:48.346 --> 00:30:52.066 A:middle
between them to find the flock
of the birds nearest to it.

599
00:30:53.016 --> 00:30:57.136 A:middle
And then, each Boid
has competing urges.

600
00:30:57.136 --> 00:30:59.446 A:middle
On the one hand, it
wants to move closer

601
00:30:59.446 --> 00:31:00.696 A:middle
to the center of the flock.

602
00:31:00.696 --> 00:31:03.886 A:middle
At the same time, it doesn't
want to get too close.

603
00:31:04.676 --> 00:31:08.986 A:middle
And so, if it gets too close to
another one it will move apart.

604
00:31:10.066 --> 00:31:12.946 A:middle
And the performance of that,
as we add more and more

605
00:31:12.946 --> 00:31:15.666 A:middle
of these Boids, could
become a problem.

606
00:31:16.466 --> 00:31:20.086 A:middle
So, we set up a performance
test to track that,

607
00:31:20.936 --> 00:31:24.216 A:middle
and this is a really
simple performance test.

608
00:31:25.576 --> 00:31:29.296 A:middle
We set up a scene with 200 Boids
and measured the time it takes

609
00:31:29.296 --> 00:31:31.686 A:middle
to update their positions
100 times,

610
00:31:31.686 --> 00:31:32.816 A:middle
and that's our performance test.

611
00:31:32.816 --> 00:31:33.716 A:middle
So, let's run that.

612
00:31:34.476 --> 00:31:36.376 A:middle
Because I care about
performance,

613
00:31:36.816 --> 00:31:39.806 A:middle
I'm going to edit my
current scheme to make sure

614
00:31:39.806 --> 00:31:41.656 A:middle
that my test step is going

615
00:31:41.656 --> 00:31:44.186 A:middle
to use the release-built
configuration

616
00:31:44.586 --> 00:31:46.436 A:middle
so that we get optimized
results.

617
00:31:47.616 --> 00:31:49.726 A:middle
And, I'll go to the
Product Test menu

618
00:31:51.376 --> 00:31:53.096 A:middle
and run my performance
test here.

619
00:31:57.526 --> 00:31:57.936 A:middle
All right.

620
00:31:58.086 --> 00:32:00.486 A:middle
And now, because I haven't run
the test before I don't have a

621
00:32:00.536 --> 00:32:02.086 A:middle
baseline, so let's go ahead

622
00:32:02.086 --> 00:32:06.536 A:middle
and set the baseline
based on that first run.

623
00:32:07.666 --> 00:32:10.366 A:middle
And now, let's try adding PGO.

624
00:32:11.256 --> 00:32:13.636 A:middle
Under the Product
menu, Perform Action,

625
00:32:14.246 --> 00:32:16.636 A:middle
down at the bottom here is this
new command I told you about,

626
00:32:16.636 --> 00:32:18.496 A:middle
Generate Optimization Profile.

627
00:32:19.136 --> 00:32:22.516 A:middle
I get two choices; I can
either run the application

628
00:32:23.616 --> 00:32:25.446 A:middle
or I can use my performance
test.

629
00:32:25.446 --> 00:32:28.016 A:middle
And, I'd like to show you how it
works with the performance test.

630
00:32:29.026 --> 00:32:33.256 A:middle
I just click Build and Run,
and Xcode, very helpfully,

631
00:32:33.396 --> 00:32:35.906 A:middle
warns me that I haven't
yet enabled PGO

632
00:32:35.906 --> 00:32:38.616 A:middle
in the Build settings
and it offers to do that.

633
00:32:38.616 --> 00:32:41.196 A:middle
So, let's go ahead and
let it enable that.

634
00:32:41.486 --> 00:32:44.236 A:middle
It's now building a special
instrumented version of our app

635
00:32:44.236 --> 00:32:48.736 A:middle
and running it using
the performance test.

636
00:32:49.136 --> 00:32:50.406 A:middle
And when those tests finish --

637
00:32:52.516 --> 00:32:55.436 A:middle
ah, I got a warning
here, an error.

638
00:32:55.436 --> 00:32:57.586 A:middle
Let me just explain
what's happened here is

639
00:32:57.616 --> 00:33:00.016 A:middle
that because we've
run the app with a lot

640
00:33:00.016 --> 00:33:02.966 A:middle
of the instrumentation
code, it runs more slowly.

641
00:33:03.246 --> 00:33:05.616 A:middle
But, this is just being
used to generate the profile

642
00:33:05.616 --> 00:33:06.656 A:middle
so that's not a problem.

643
00:33:07.026 --> 00:33:10.016 A:middle
I'm going to go back to the
Project Navigator a minute

644
00:33:10.616 --> 00:33:13.666 A:middle
and show you that Xcode has
added this new Optimization

645
00:33:13.666 --> 00:33:14.836 A:middle
Profiles folder.

646
00:33:15.446 --> 00:33:18.806 A:middle
And inside of that, if you can
see it, there's my profile data.

647
00:33:20.066 --> 00:33:20.826 A:middle
So, that's great!

648
00:33:21.416 --> 00:33:23.776 A:middle
PGO is enabled, we
have a profile.

649
00:33:23.776 --> 00:33:25.676 A:middle
Let's rerun those
performance tests.

650
00:33:26.276 --> 00:33:27.786 A:middle
We'll go back to
run Product Test,

651
00:33:28.946 --> 00:33:30.156 A:middle
and see how much does it help?

652
00:33:30.156 --> 00:33:34.956 A:middle
And the tests are running now.

653
00:33:36.376 --> 00:33:39.036 A:middle
And, wow, we got a 21%
improvement just like that.

654
00:33:39.386 --> 00:33:41.696 A:middle
We didn't have to change the
code or do anything else.

655
00:33:42.516 --> 00:33:49.286 A:middle
[ Applause ]

656
00:33:49.786 --> 00:33:51.276 A:middle
So, that is PGO.

657
00:33:51.626 --> 00:33:54.836 A:middle
It's a great new feature to help
you get even more performance,

658
00:33:54.946 --> 00:33:57.346 A:middle
when you care about
getting every last drop

659
00:33:57.346 --> 00:33:58.006 A:middle
out of your code.

660
00:33:59.136 --> 00:34:01.186 A:middle
Continuing on this
theme of performance,

661
00:34:01.266 --> 00:34:04.736 A:middle
I'd like to turn the stage over
to Nadav Rotem, my colleague,

662
00:34:04.736 --> 00:34:08.936 A:middle
to talk about advances
in vectorization

663
00:34:09.536 --> 00:34:09.966 A:middle
&gt;&gt; Thank you, Bob.

664
00:34:10.565 --> 00:34:10.735 A:middle
Hi.

665
00:34:11.516 --> 00:34:16.476 A:middle
[ Applause ]

666
00:34:16.976 --> 00:34:21.896 A:middle
So, Last year with Xcode 5 we've
introduced a new optimization

667
00:34:22.186 --> 00:34:23.856 A:middle
called loop vectorization.

668
00:34:24.156 --> 00:34:28.485 A:middle
And, I would like to remind
you what loop vectorization is.

669
00:34:29.085 --> 00:34:33.186 A:middle
So, modern processors
have vector instructions.

670
00:34:33.616 --> 00:34:37.025 A:middle
These instructions can process
multiple scalars at once.

671
00:34:37.505 --> 00:34:40.406 A:middle
And loop vectorization is
the compiler optimization

672
00:34:40.766 --> 00:34:43.866 A:middle
that accelerates loops using
these vector instructions.

673
00:34:44.866 --> 00:34:45.735 A:middle
And let's see how it's done.

674
00:34:46.295 --> 00:34:48.266 A:middle
If you can see the code
on the screen here,

675
00:34:48.266 --> 00:34:49.656 A:middle
you'll see that it's
a simple program

676
00:34:50.266 --> 00:34:52.716 A:middle
that accumulates all
the numbers in the array

677
00:34:53.025 --> 00:34:54.436 A:middle
into one variable, into sum.

678
00:34:54.496 --> 00:34:59.016 A:middle
And, the natural way of
executing this code is

679
00:34:59.016 --> 00:35:02.366 A:middle
to load one number at a time and
save it into the variable sum.

680
00:35:02.426 --> 00:35:04.586 A:middle
And then, load another
number and save it into sum.

681
00:35:05.236 --> 00:35:07.736 A:middle
But, there's the better
way of executing this code.

682
00:35:09.076 --> 00:35:11.856 A:middle
What the loop vector does
for you automatically,

683
00:35:12.186 --> 00:35:15.596 A:middle
is that it introduces a new
temporary variable, temp4.

684
00:35:15.596 --> 00:35:19.436 A:middle
Now, this is a vector register,
a vector temporary variable.

685
00:35:20.576 --> 00:35:23.586 A:middle
And, this allows us to
load four numbers at a time

686
00:35:23.856 --> 00:35:25.246 A:middle
and add four numbers at a time,

687
00:35:25.556 --> 00:35:26.766 A:middle
and we do it for
the entire array.

688
00:35:27.206 --> 00:35:29.136 A:middle
So, this is obviously
much faster

689
00:35:29.136 --> 00:35:32.236 A:middle
because we're processing
four numbers at once instead

690
00:35:32.236 --> 00:35:34.896 A:middle
of processing one
number at a time.

691
00:35:35.036 --> 00:35:37.416 A:middle
And, when you finish
scanning the array we need

692
00:35:37.416 --> 00:35:40.186 A:middle
to take the four numbers
from that temporary register

693
00:35:40.186 --> 00:35:42.076 A:middle
and add them together,
but it doesn't matter

694
00:35:42.076 --> 00:35:43.826 A:middle
because usually an
array is pretty big.

695
00:35:44.836 --> 00:35:48.716 A:middle
So, this is how loop
vectorization accelerates loops

696
00:35:48.716 --> 00:35:49.846 A:middle
and makes your code run faster

697
00:35:49.956 --> 00:35:51.466 A:middle
so that you don't have
to change your code.

698
00:35:52.696 --> 00:35:56.956 A:middle
So, in Xcode 6 we've improved
loop vectorization in a number

699
00:35:56.956 --> 00:35:58.726 A:middle
of ways, where first of all,

700
00:35:59.006 --> 00:36:01.126 A:middle
we've improved the analysis
of complicated loops.

701
00:36:01.716 --> 00:36:03.976 A:middle
This means that the
LLVM will be able

702
00:36:03.976 --> 00:36:07.906 A:middle
to analyze more complicated
loops and vectorize more loops

703
00:36:07.906 --> 00:36:09.326 A:middle
in your code, which is great.

704
00:36:09.696 --> 00:36:12.696 A:middle
We've also integrated the
Loop Vectorizer with PGO,

705
00:36:12.696 --> 00:36:14.146 A:middle
that Bob just mentioned.

706
00:36:14.596 --> 00:36:18.166 A:middle
So, this means that when PGO is
available the Loop Vectorizer

707
00:36:18.236 --> 00:36:19.896 A:middle
will be able to make
better decisions

708
00:36:20.406 --> 00:36:21.436 A:middle
when vectorizing your code.

709
00:36:22.436 --> 00:36:27.016 A:middle
We've also improved the X86
and ARM64 in coding support.

710
00:36:27.096 --> 00:36:28.066 A:middle
Now this means two things.

711
00:36:28.766 --> 00:36:31.616 A:middle
First of all, the Loop
Vectorizer has a better

712
00:36:31.616 --> 00:36:35.096 A:middle
understanding of the processor
so it can predict better

713
00:36:35.376 --> 00:36:37.806 A:middle
when it is profitable
to vectorize your codes.

714
00:36:38.226 --> 00:36:40.266 A:middle
And the second thing
that it means is

715
00:36:40.266 --> 00:36:44.096 A:middle
that when it vectorize your
code it'll generate better,

716
00:36:44.096 --> 00:36:46.216 A:middle
more optimized code sequences,

717
00:36:46.286 --> 00:36:47.756 A:middle
so that your code
would run faster.

718
00:36:49.926 --> 00:36:51.576 A:middle
And, the last feature
that I want to talk to you

719
00:36:51.576 --> 00:36:54.156 A:middle
about is specialization
of loop variables.

720
00:36:56.896 --> 00:37:02.946 A:middle
So, most variables in your
code are only known at runtime.

721
00:37:03.796 --> 00:37:09.396 A:middle
These variables can be arguments
or computed expressions,

722
00:37:09.396 --> 00:37:12.356 A:middle
and compiler doesn't know
the values of these variables

723
00:37:12.656 --> 00:37:15.076 A:middle
at compile time,
only at runtime.

724
00:37:16.186 --> 00:37:17.776 A:middle
And in many times,

725
00:37:18.176 --> 00:37:21.556 A:middle
the Vectorizer cannot vectorize
your code unless the value

726
00:37:21.556 --> 00:37:23.536 A:middle
of these variables is
known to be constant.

727
00:37:24.146 --> 00:37:25.416 A:middle
So, let's take a
look at the example

728
00:37:25.416 --> 00:37:26.266 A:middle
that I showed you earlier.

729
00:37:26.496 --> 00:37:30.026 A:middle
So, this is a simple loop and
I modified it a little bit

730
00:37:30.026 --> 00:37:32.066 A:middle
and I introduced
the Step variable.

731
00:37:32.356 --> 00:37:36.196 A:middle
So now, instead of consecutively
scanning all of the elements

732
00:37:36.196 --> 00:37:38.796 A:middle
in the array, we jump
and skip some elements,

733
00:37:38.796 --> 00:37:41.216 A:middle
and we go in step
of variable Step.

734
00:37:42.826 --> 00:37:44.366 A:middle
Now, we can't vectorize
this code

735
00:37:44.366 --> 00:37:48.056 A:middle
because these elements are
not consecutive in memory.

736
00:37:48.056 --> 00:37:51.466 A:middle
We can't use these vector
registers to load a few elements

737
00:37:51.466 --> 00:37:52.766 A:middle
and then add them together.

738
00:37:52.766 --> 00:37:56.266 A:middle
It's won't work unless
Step is equal to one.

739
00:37:56.586 --> 00:37:59.236 A:middle
Well, in many cases
Step is equal to one.

740
00:38:00.236 --> 00:38:01.046 A:middle
So, what do we do?

741
00:38:01.726 --> 00:38:04.776 A:middle
Well, we've introduced a
new optimization that's

742
00:38:04.776 --> 00:38:05.976 A:middle
called Specialization.

743
00:38:06.706 --> 00:38:09.546 A:middle
What we do is we create
multiple versions of the loop.

744
00:38:10.206 --> 00:38:13.036 A:middle
In one version of the loop
we assume that step is equal

745
00:38:13.036 --> 00:38:15.176 A:middle
to one, and then we
vectorize the code

746
00:38:15.896 --> 00:38:17.046 A:middle
and make the code run faster.

747
00:38:17.946 --> 00:38:20.706 A:middle
But, in another version of the
loop we don't assume anything

748
00:38:20.756 --> 00:38:24.316 A:middle
and the code runs
as-is -- scalar.

749
00:38:25.396 --> 00:38:29.106 A:middle
And then, we add code
for selecting at runtime

750
00:38:29.636 --> 00:38:31.586 A:middle
which version of
the loop to run.

751
00:38:31.926 --> 00:38:35.056 A:middle
If Step happened to
be one, then we go

752
00:38:35.056 --> 00:38:36.956 A:middle
and execute the vectorized
version.

753
00:38:37.136 --> 00:38:38.286 A:middle
But, if Step is not equal

754
00:38:38.286 --> 00:38:40.956 A:middle
to one then we execute
the regular version.

755
00:38:41.236 --> 00:38:43.206 A:middle
And this compiler,
this new feature,

756
00:38:43.206 --> 00:38:45.666 A:middle
allows the Loop Vectorizer

757
00:38:45.736 --> 00:38:50.146 A:middle
to vectorize a lot more
loops, and it's great.

758
00:38:50.146 --> 00:38:52.106 A:middle
Okay. So, this was
loop vectorization.

759
00:38:52.626 --> 00:38:56.606 A:middle
But, in Xcode 6 we've also added
a new kind of vectorization.

760
00:38:56.816 --> 00:38:59.916 A:middle
This is -- this new vectorizer
is not a loop vectorizer.

761
00:39:00.206 --> 00:39:03.156 A:middle
It's called SLP Vectorizer,
which stands

762
00:39:03.156 --> 00:39:05.386 A:middle
for Superword Level Parallelism,

763
00:39:05.686 --> 00:39:08.646 A:middle
and it extracts parallelism
beyond loops.

764
00:39:09.116 --> 00:39:11.726 A:middle
What this SLP Vectorizer
does is that it looks

765
00:39:11.726 --> 00:39:15.426 A:middle
for multiple scalars in your
code and it glues them together

766
00:39:15.426 --> 00:39:16.686 A:middle
into vector instructions.

767
00:39:18.136 --> 00:39:20.496 A:middle
Let's see how it's done.

768
00:39:21.696 --> 00:39:23.596 A:middle
So, on the screen you
see a very simple struct.

769
00:39:24.476 --> 00:39:26.936 A:middle
This struct has two
members, x and y.

770
00:39:27.596 --> 00:39:28.816 A:middle
They're consecutive in memory.

771
00:39:29.766 --> 00:39:32.246 A:middle
And, we have a simple
function that converts units

772
00:39:32.946 --> 00:39:34.326 A:middle
from feet to centimeters.

773
00:39:34.496 --> 00:39:36.086 A:middle
Now, this is a very
simple conversion.

774
00:39:36.136 --> 00:39:39.486 A:middle
All we have to do is
load the x member,

775
00:39:39.486 --> 00:39:41.206 A:middle
multiply it by a
constant, and do it again.

776
00:39:41.206 --> 00:39:42.246 A:middle
And, we do the same thing for y.

777
00:39:42.576 --> 00:39:46.606 A:middle
And of course, the natural
way of executing this code is

778
00:39:46.636 --> 00:39:49.746 A:middle
to do it consecutively;
load variable x,

779
00:39:49.836 --> 00:39:51.646 A:middle
multiply it, save it back.

780
00:39:52.736 --> 00:39:56.396 A:middle
Load variable y, multiply
it, and save it back.

781
00:39:57.076 --> 00:39:59.556 A:middle
But again, there's a
better way of doing it,

782
00:39:59.866 --> 00:40:01.956 A:middle
and this is what the
SLP Vectorizer does.

783
00:40:02.486 --> 00:40:05.316 A:middle
We can load x and y together
because they're consecutive

784
00:40:05.316 --> 00:40:09.026 A:middle
in memory, multiply
them together again,

785
00:40:09.026 --> 00:40:10.316 A:middle
and save them back to memory.

786
00:40:10.316 --> 00:40:19.046 A:middle
And, this is SLP vectorization
SLP vectorization is very

787
00:40:19.046 --> 00:40:21.376 A:middle
beneficial for some
kinds of application,

788
00:40:21.786 --> 00:40:24.906 A:middle
mainly numeric applications,
and we see great speedups.

789
00:40:25.186 --> 00:40:27.386 A:middle
It may not speed
up all programs,

790
00:40:27.996 --> 00:40:30.096 A:middle
but it definitely
speeds up a lot

791
00:40:30.166 --> 00:40:32.546 A:middle
of numerically complex
applications.

792
00:40:33.816 --> 00:40:40.236 A:middle
So to summarize, we've improved
loop vectorization in Xcode 6

793
00:40:40.526 --> 00:40:42.056 A:middle
and we've introduced a new kind

794
00:40:42.056 --> 00:40:44.896 A:middle
of vectorization called
SLP vectorization.

795
00:40:46.866 --> 00:40:49.676 A:middle
Now in Xcode 5, when we
introduced the Loop Vectorizer

796
00:40:49.916 --> 00:40:52.646 A:middle
we did not enable it by default
and you had to go into one

797
00:40:52.646 --> 00:40:54.816 A:middle
of the settings and
select Loop Vectorization

798
00:40:54.816 --> 00:40:56.186 A:middle
and then Loop Vectorization
worked.

799
00:40:56.596 --> 00:40:59.426 A:middle
Well, in Xcode 6 you
don't have to do anything

800
00:40:59.426 --> 00:41:02.136 A:middle
because both the
new SLP Vectorizer

801
00:41:02.536 --> 00:41:05.776 A:middle
and the improved Loop Vectorizer
are enabled by default

802
00:41:05.916 --> 00:41:08.036 A:middle
when you build your
application in a release mode.

803
00:41:08.306 --> 00:41:09.746 A:middle
This means that you don't
need to do anything.

804
00:41:09.746 --> 00:41:11.846 A:middle
Just compile your
application in release mode

805
00:41:12.346 --> 00:41:15.016 A:middle
and the improved LLVM will
make your code run faster.

806
00:41:18.916 --> 00:41:20.856 A:middle
Okay. So, we talked
about a number

807
00:41:20.856 --> 00:41:23.036 A:middle
of performance features in LLVM.

808
00:41:23.276 --> 00:41:25.486 A:middle
We talked about PGO, we
talked about vectorization,

809
00:41:26.656 --> 00:41:29.696 A:middle
but both of these
features are features

810
00:41:29.696 --> 00:41:32.806 A:middle
of a static C and C++ compiler.

811
00:41:33.316 --> 00:41:36.346 A:middle
But, LLVM is essential
technology here at Apple,

812
00:41:36.346 --> 00:41:38.156 A:middle
that's used by many projects.

813
00:41:38.506 --> 00:41:40.126 A:middle
And, one of the projects
that I want to talk to you

814
00:41:40.126 --> 00:41:43.266 A:middle
about today is accelerating
JavaScript code.

815
00:41:47.356 --> 00:41:52.126 A:middle
Well, WebKit is another
important technology.

816
00:41:52.126 --> 00:41:54.406 A:middle
It's the heart of the
Safari Web Browser.

817
00:41:55.166 --> 00:41:57.646 A:middle
And, WebKit needs to
execute JavaScript code

818
00:41:58.046 --> 00:42:00.326 A:middle
because JavaScript is
everywhere in every web page.

819
00:42:01.806 --> 00:42:03.236 A:middle
And, WebKit has an interpreter,

820
00:42:03.536 --> 00:42:05.826 A:middle
so when you load your Facebook
page, or any other page,

821
00:42:06.156 --> 00:42:09.966 A:middle
WebKit starts executing your
code with the interpreter.

822
00:42:11.356 --> 00:42:13.906 A:middle
But, WebKit also has
two JIT compilers

823
00:42:14.276 --> 00:42:15.926 A:middle
to accelerate your code.

824
00:42:17.156 --> 00:42:19.466 A:middle
When WebKit sees that you
execute the same function,

825
00:42:19.466 --> 00:42:21.816 A:middle
the same JavaScript
functions over

826
00:42:21.816 --> 00:42:23.396 A:middle
and over again, it says, "Huh.

827
00:42:23.716 --> 00:42:27.106 A:middle
Let's take a little bit of time
to compile it really quickly

828
00:42:27.106 --> 00:42:29.396 A:middle
so that it will run a little bit
faster than the interpreter."

829
00:42:29.876 --> 00:42:30.956 A:middle
So, this is the fast JIT.

830
00:42:32.366 --> 00:42:36.236 A:middle
And, when WebKit sees that you
execute a function many times,

831
00:42:36.806 --> 00:42:39.726 A:middle
then it says, "All right,
let's also take the time

832
00:42:39.936 --> 00:42:41.596 A:middle
and optimize this
function real quick,

833
00:42:41.836 --> 00:42:44.256 A:middle
so that it will run a
little bit more faster,

834
00:42:44.256 --> 00:42:45.286 A:middle
a little bit faster."

835
00:42:45.676 --> 00:42:49.736 A:middle
So, we have the interpreter,
we have the fast JIT,

836
00:42:50.126 --> 00:42:54.176 A:middle
and we have the optimizing
JIT, and there are tradeoffs

837
00:42:54.176 --> 00:42:56.836 A:middle
between compile time and
the quality of the code.

838
00:42:57.186 --> 00:43:00.256 A:middle
And this works really great,

839
00:43:01.136 --> 00:43:03.096 A:middle
except that JavaScript
is evolving.

840
00:43:04.146 --> 00:43:05.986 A:middle
People start writing large,

841
00:43:06.106 --> 00:43:08.696 A:middle
compute intensive
applications in JavaScript.

842
00:43:09.346 --> 00:43:13.356 A:middle
People then compile C++
programs into JavaScript

843
00:43:13.776 --> 00:43:15.326 A:middle
and run them in the browser.

844
00:43:15.586 --> 00:43:18.256 A:middle
You can even compile
a Quake3 and run it

845
00:43:18.256 --> 00:43:20.446 A:middle
in your browser today,
which is --

846
00:43:20.486 --> 00:43:22.266 A:middle
some people like it [laughter].

847
00:43:23.586 --> 00:43:25.716 A:middle
Yeah, it's great.

848
00:43:26.436 --> 00:43:30.956 A:middle
But, it's a new-use case
and we need a new compiler

849
00:43:31.306 --> 00:43:32.356 A:middle
to support this use-case,

850
00:43:32.926 --> 00:43:35.476 A:middle
and this is where LLVM
comes into the picture.

851
00:43:36.986 --> 00:43:41.446 A:middle
So, we're adding LLVM as a
fourth tier compiler to WebKit.

852
00:43:43.896 --> 00:43:45.796 A:middle
Functions that run many, many,

853
00:43:45.796 --> 00:43:48.906 A:middle
many times are now
compiled with LLVM.

854
00:43:49.096 --> 00:43:52.716 A:middle
And, LLVM is tuned for making
the most out of your code,

855
00:43:52.716 --> 00:43:55.736 A:middle
for really trying hard
to optimize your code

856
00:43:55.966 --> 00:43:59.366 A:middle
and to generate excellent
code quality.

857
00:43:59.746 --> 00:44:03.106 A:middle
And again, there's a
tradeoff between compiled time

858
00:44:03.386 --> 00:44:06.286 A:middle
and the quality of the code,
so WebKit really waits for you

859
00:44:06.286 --> 00:44:09.426 A:middle
to execute that function
many, many times as you do

860
00:44:09.426 --> 00:44:10.976 A:middle
in computing intensive
applications

861
00:44:11.016 --> 00:44:11.856 A:middle
that you run in the browser.

862
00:44:11.856 --> 00:44:17.746 A:middle
But, compiling JavaScript
with LLVM is very different

863
00:44:17.746 --> 00:44:21.126 A:middle
from compiling C or Objective-C
because JavaScript --

864
00:44:21.786 --> 00:44:24.446 A:middle
it's a great language,
it's a dynamic language,

865
00:44:24.446 --> 00:44:26.226 A:middle
and if you look at the code
on the screen you'll see

866
00:44:26.226 --> 00:44:27.726 A:middle
that there are no types.

867
00:44:28.356 --> 00:44:33.086 A:middle
There's this n argument
here, but what is n?

868
00:44:33.086 --> 00:44:34.246 A:middle
Is it an integer?

869
00:44:34.326 --> 00:44:35.346 A:middle
Is it double?

870
00:44:35.626 --> 00:44:36.436 A:middle
Is it a class?

871
00:44:37.306 --> 00:44:38.506 A:middle
It can be a lot of
different things.

872
00:44:39.706 --> 00:44:41.316 A:middle
So, how do we compile it?

873
00:44:41.906 --> 00:44:48.616 A:middle
Well luckily, WebKit executed
this function many, many, many,

874
00:44:48.616 --> 00:44:50.376 A:middle
many times before
with the interpreter,

875
00:44:50.526 --> 00:44:56.636 A:middle
so it knows that in the last
1000 times n was an integer.

876
00:44:57.006 --> 00:45:00.016 A:middle
So now, we can compile this code
assuming that n is an integer,

877
00:45:00.996 --> 00:45:03.406 A:middle
except that someone made decide

878
00:45:03.406 --> 00:45:06.466 A:middle
to pass an n that's
not an integer.

879
00:45:06.466 --> 00:45:09.206 A:middle
Someone may decide to
pass a double or a class

880
00:45:09.736 --> 00:45:12.266 A:middle
and then everything will
break and we can't allow that.

881
00:45:12.786 --> 00:45:13.866 A:middle
So, what do we do?

882
00:45:14.216 --> 00:45:15.606 A:middle
We use a technique
that's very similar

883
00:45:15.606 --> 00:45:16.936 A:middle
to what we did with
the vectorizer.

884
00:45:17.596 --> 00:45:18.336 A:middle
We add checks.

885
00:45:18.336 --> 00:45:19.896 A:middle
We make assumptions
and we add checks.

886
00:45:20.306 --> 00:45:21.946 A:middle
We assume that n is an integer.

887
00:45:22.806 --> 00:45:24.976 A:middle
We assume that n
does not overflow.

888
00:45:24.976 --> 00:45:28.476 A:middle
And then, we verify our
assumptions at runtime.

889
00:45:29.526 --> 00:45:30.486 A:middle
Okay, that's great.

890
00:45:30.966 --> 00:45:32.016 A:middle
But, what is the fallback?

891
00:45:32.016 --> 00:45:32.506 A:middle
What do we do?

892
00:45:33.276 --> 00:45:35.656 A:middle
When our assumptions
fail we have to go back

893
00:45:35.656 --> 00:45:38.676 A:middle
to the interpreter because only
the interpreter can handle all

894
00:45:38.676 --> 00:45:40.736 A:middle
these cases, all
these extreme cases.

895
00:45:42.426 --> 00:45:45.616 A:middle
But, moving back to the
interpreter is not simple

896
00:45:46.106 --> 00:45:47.826 A:middle
because we started
executing it in a code

897
00:45:47.826 --> 00:45:48.976 A:middle
and the function made changes.

898
00:45:48.976 --> 00:45:50.976 A:middle
We can't just start executing
it from the beginning.

899
00:45:51.736 --> 00:45:54.536 A:middle
So, we developed a technology
that's called On-Stack

900
00:45:54.536 --> 00:45:57.406 A:middle
Replacement, which is
techniques that is used

901
00:45:57.856 --> 00:46:01.856 A:middle
to migrate the state of the
program from the JITed code

